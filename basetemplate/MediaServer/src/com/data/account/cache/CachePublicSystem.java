package com.data.account.cache;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.base.component.SimpleScheduleComponent;
import com.base.redis.AbstractCache;
import com.base.redis.RedisClient;
import com.base.rmi.IRemoteCode;
import com.data.account.data.TableData;
import com.data.account.factory.TableDataFactory;
import com.util.print.LogFactory;

import redis.clients.jedis.ScanParams;
import redis.clients.jedis.ScanResult;

/**
 * This file is generated by system automatically.Don't Modify It.
 *
 * @author System
 */
@IRemoteCode(code = "CachePublicSystem", type = "public", desc = "t_p_table : [TableID]")
public final class CachePublicSystem extends AbstractCache
{
    private final String KEY_TABLE = "Jump_Table:%s";

    private static final String KEY_SYSTEM_MAX_ID = "jump_system_table:%s";

    private Map<Integer, List<String>> keyMap = new HashMap<>();

    public long lockTable(int tableID)
    {
        String key = String.format(KEY_TABLE, tableID);
        RedisClient client = getRedisClient();
        return client.lock(key);
    }

    public void unlockTable(int tableID, long value)
    {
        String key = String.format(KEY_TABLE, tableID);
        RedisClient client = getRedisClient();
        client.unlock(key, value);
    }

    public TableData getTableData(int tableID)
    {
        String key = String.format(KEY_TABLE, tableID);
        RedisClient client = getRedisClient();
        TableData info = client.get(key, TableData.class);
        if (info == null)
        {
            info = TableDataFactory.getDao().query("select * from t_p_table where `TableID`=?;", tableID);
            if (null != info)
            {
                client.set(key, info);
            }
        }
        resetChanged(info);
        return info;
    }

    public TableData getTableDataByLock(int tableID)
    {
        long lock = lockTable(tableID);
        try
        {
            return getTableData(tableID);
        }
        finally
        {
            unlockTable(tableID, lock);
        }
    }

    public void updateTableData(final TableData info)
    {
        if (!info.isChanged())
            return;

        RedisClient client = getRedisClient();

        String key = String.format(KEY_TABLE, info.getTableID());
        client.set(key, info);

        synchronized (keyMap)
        {
            if (!keyMap.containsKey(client.getRedisID()))
                keyMap.put(client.getRedisID(), new ArrayList<>());

            keyMap.get(client.getRedisID()).add(key);
        }

        resetChanged(info);
    }

    public void updateTableDataByLock(final TableData info)
    {
        long lock = lockTable(info.getTableID());
        try
        {
            updateTableData(info);
        }
        finally
        {
            unlockTable(info.getTableID(), lock);
        }
    }

    public boolean saveDB(List<TableData> list)
    {
        int[] result = TableDataFactory.getDao().addOrUpdateBatch(list);
        if (result == null)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

    @Override
    public boolean save()
    {
        Map<Integer, List<String>> tempMap = new HashMap<>();

        synchronized (keyMap)
        {
            tempMap.putAll(keyMap);
            keyMap.clear();
        }

        Set<Integer> redisList = tempMap.keySet();
        for (int redisID : redisList)
        {
            RedisClient client = getRedisClient(redisID);
            List<TableData> infoList = new ArrayList<>();
            List<String> keyList = tempMap.get(redisID);

            try
            {
                for (String str : keyList)
                {
                    TableData info = client.get(str, TableData.class);
                    if (info != null)
                        infoList.add(info);
                    else
                        LogFactory.error("Update TableData -- info is not exist.key:{},client:{}", str, client.getRedisID());
                }

                if (!saveDB(infoList))
                {
                    synchronized (keyMap)
                    {
                        if (keyMap.containsKey(redisID))
                            keyMap.get(redisID).addAll(keyList);
                        else
                            keyMap.put(redisID, keyList);
                    }

                    LogFactory.error("Update TableData Failed,client:" + client.getRedisID());
                }
            }
            catch (Exception e)
            {
                synchronized (keyMap)
                {
                    if (keyMap.containsKey(redisID))
                        keyMap.get(redisID).addAll(keyList);
                    else
                        keyMap.put(redisID, keyList);
                }

                LogFactory.error("Update TableData Exception,client:" + client.getRedisID(), e);
                return false;
            }
        }

        return true;
    }

    @Override
    public boolean saveAll()
    {
        List<RedisClient> list = new ArrayList<>();
        list.add(getRedisClient());
        for (RedisClient client : list)
        {
            try
            {
                boolean isFinish = false;
                String cursor = "0";
                while (!isFinish)
                {
                    ScanResult<String> resultList = client.scan(cursor, SAVE_COUNT, "Table:*");
                    cursor = resultList.getCursor();
                    isFinish = resultList.getCursor().equals(ScanParams.SCAN_POINTER_START);

                    List<TableData> infoList = new ArrayList<>();
                    List<String> keyList = resultList.getResult();
                    for (String key : keyList)
                    {
                        TableData info = client.get(key, TableData.class);
                        if (info != null)
                        {
                            infoList.add(info);
                        }
                    }

                    boolean result = saveDB(infoList);
                    if (!result)
                    {
                        LogFactory.error("TableData Save All Failed.size:{}", infoList.size());
                    }
                }
            }
            catch (Exception e)
            {
                LogFactory.error("TableData Save All Exception.", e);
            }
        }

        return true;
    }

    public boolean reload(int tableID)
    {
        String key = String.format(KEY_TABLE, tableID);
        RedisClient client = getRedisClient();
        TableData info = TableDataFactory.getDao().query("select * from t_p_table where `TableID`=?;", tableID);
        if (null != info)
        {
            client.set(key, info);
        }
        return true;
    }

    /**
     * 取得表的最大ID
     * 
     * @param type
     *            TableType
     * @return
     */
    public long getTableMaxID(int type)
    {
        String key = String.format(KEY_SYSTEM_MAX_ID, type);
        long val = getRedisClient().incr(key);

        TableData info = new TableData();
        info.setTableID(type);
        info.setValue(val);

        SimpleScheduleComponent.schedule((job) -> {
            updateTableData(info);
        });

        return val;
    }

    /**
     * 游戏重启时，判断重置自增值(incr 和 getSet 一对原子操作,设置修改自增值)
     * 1.游戏重启，缓存正常，以缓存为准
     * 2.游戏重启，缓存重启，以最大值为准
     * 3.游戏重启，合服最大值改变，以数据库为准
     * 
     * @param tableID
     * @param maxValue
     */
    public synchronized void resetTableMaxID(int tableID, long maxValue)
    {
        if (maxValue < 10000)
            maxValue = 10000;

        String key = String.format(KEY_SYSTEM_MAX_ID, tableID);
        long val = getRedisClient().incr(key);
        long max = Math.max(val, maxValue);
        // 如果缓存的比数据库的小，重置为数据库的值
        if (val < max)
            getRedisClient().getSet(key, String.valueOf(max + 10));

        TableData info = new TableData();
        info.setTableID(tableID);
        info.setValue(max);

        updateTableData(info);
    }

}
