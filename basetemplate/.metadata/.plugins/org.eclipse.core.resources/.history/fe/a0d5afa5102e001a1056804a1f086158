package com.game.component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import com.base.component.AbstractComponent;
import com.base.net.CommonMessage;
import com.game.object.player.GamePlayer;
import com.google.protobuf.GeneratedMessage.Builder;
import com.util.HttpUtil;
import com.util.JsonUtil;
import com.util.NamedThreadFactory;
import com.util.StringUtil;
import com.util.print.LogFactory;

/**
 * 玩家管理组件
 * 
 * @author dream
 *
 */
public class GamePlayerComponent extends AbstractComponent
{
    private static Map<Long, GamePlayer> gamePlayerMap = new HashMap<>();

    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    private static String Access_Token = "";

    private static String token_url = "https://accounts.google.com/o/oauth2/token";
    private static String redirect_url = "https://whalerun-project.firebaseapp.com/__/auth/handler";
    private static String grant_type = "refresh_token";
    private static String client_id = "387829453470-aitrnijhq7o5l2srabvb12gerl309ajs.apps.googleusercontent.com";
    private static String client_secret = "zmmoJP3F_Z5azCuktHh9DwcY";
    private static String refresh_token = "1//06rXCWEq1cElpCgYIARAAGAYSNwF-L9IrMA84PfWd7EvlKNKNteCXG0FHWWhFqZOy6TCK3QdmWL0M8VSkC6IgFwXBmkE2CofiGJM";

    private static String get_url = "https://www.googleapis.com/androidpublisher/v2/applications/%s/purchases/products/%s/tokens/%s?access_token=%s";

    private static String PackageName = "";

    private static ScheduledExecutorService refreshJob;

    public static void addPlayer(long userID, GamePlayer player)
    {
        lock.writeLock().lock();
        try
        {
            gamePlayerMap.put(userID, player);
        }
        finally
        {
            lock.writeLock().unlock();
        }
    }

    public static void removePlayer(long userID)
    {
        lock.writeLock().lock();
        try
        {
            gamePlayerMap.remove(userID);
        }
        finally
        {
            lock.writeLock().unlock();
        }
    }

    /**
     * 获取在线玩家（玩家下线但是服务器会保存问题）
     * 
     * @return
     */
    public static int getOnlineCount()
    {
        List<GamePlayer> players = getAllPlayer();

        players.removeIf((player) -> {
            return !player.getNetworkModule().isConnect();
        });

        return players.size();
    }

    /**
     * 判断玩家是否在线
     * 
     * @param userID
     * @return
     */
    public static boolean isOnline(long userID)
    {
        GamePlayer player = getPlayerByUserID(userID);

        if (player != null)
        {
            return player.getNetworkModule().isConnect();
        }

        return false;
    }

    /**
     * 获取所有玩家数量
     * 
     * @return
     */
    public static int getPlayerCount()
    {
        return gamePlayerMap.size();
    }

    public static List<GamePlayer> getAllPlayer()
    {
        lock.readLock().lock();
        try
        {
            return new ArrayList<>(gamePlayerMap.values());
        }
        finally
        {
            lock.readLock().unlock();
        }
    }

    public static GamePlayer getPlayerByUserID(long userID)
    {
        GamePlayer player = null;

        lock.readLock().lock();
        try
        {
            player = gamePlayerMap.get(userID);
        }
        finally
        {
            lock.readLock().unlock();
        }
        return player;
    }

    @Override
    public boolean initialize()
    {
        refreshJob = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("refresh-token"));
        refreshJob.scheduleWithFixedDelay(() -> refreshToken(), 3, 1 * 60, TimeUnit.SECONDS);
        return true;
    }

    @Override
    public void stop()
    {
        refreshJob.shutdown();

        List<GamePlayer> list = new ArrayList<>();
        list.addAll(gamePlayerMap.values());

        // 踢除玩家
        for (GamePlayer p : list)
        {
            p.getSenderModule().sendKickPlayer();
        }

        list.forEach(p -> {
            p.disconnect(p.getNetworkModule().getClientConnection(), true);
            p.save();
        });

        LogFactory.info("gameplayer disconnect. count" + list.size());
        gamePlayerMap.clear();
    }

    /**
     * 定时保存
     */
    public static void save()
    {
        try
        {
            List<GamePlayer> list = getAllPlayer();
            long time = System.currentTimeMillis();

            for (GamePlayer player : list)
            {
                player.jobSave();
            }

            if (System.currentTimeMillis() - time > 5000)
            {
                LogFactory.warn(String.format("GamePlayerComponent : save player spend too much time -- %d", System.currentTimeMillis() - time));
            }
        }
        catch (Exception e)
        {
            LogFactory.error("GamePlayerComponent Exception:", e);
        }
    }

    public static void sendToAll(int code, Builder<?> builder, GamePlayer except)
    {
        List<GamePlayer> list = getAllPlayer();
        for (GamePlayer player : list)
        {
            if (player != except && player.getNetworkModule().isConnect())
                player.sendMessage(code, builder);
        }
    }

    public static void sendToAll(CommonMessage msg, GamePlayer except)
    {
        List<GamePlayer> list = getAllPlayer();
        for (GamePlayer player : list)
        {
            if (player != except)
                player.sendMessage(msg);
        }
    }

    public static class RefreshJson
    {
        public String access_token;
        public String expires_in;
        public String scope;
        public String token_type;
    }

    /**
     * 刷新token
     * 
     * @return
     */
    public static boolean refreshToken()
    {
        try
        {
            Map<String, String> map = new HashMap<>();
            map.put("grant_type", grant_type);
            map.put("client_id", client_id);
            map.put("client_secret", client_secret);
            map.put("refresh_token", refresh_token);
            map.put("redirect_url", redirect_url);

            String result = HttpUtil.doPost(token_url, map, "UTF-8");
            if (result != null && !result.isEmpty())
            {
                RefreshJson json = JsonUtil.parseStringToObject(result, RefreshJson.class);
                if (json != null)
                {
                    Access_Token = json.access_token;
                    LogFactory.error("刷新 Access_Token:{}", Access_Token);
                    return true;
                }
            }
        }
        catch (Exception e)
        {
            LogFactory.error("", e);
        }

        return false;
    }

    /**
     * 验证
     * 
     * @param productID
     * @param purchaseToken
     * @return
     */
    public static int checkPay(String productID, String purchaseToken)
    {
        try
        {
            String url = String.format(get_url, PackageName, productID, purchaseToken, Access_Token);
            String result = HttpUtil.doGet(url, "UTF-8");
            if (!StringUtil.isNullOrEmpty(result))
            {
                GetResponseData getResponseData = JsonUtil.parseStringToObject(result, GetResponseData.class);
                if (getResponseData != null)
                {
                    LogFactory.error("url:{},result:{}", url, result);
                    if (getResponseData.purchaseState == 1)
                        return getResponseData.purchaseState;
                }
                else
                {
                    LogFactory.error("checkPay Exception.result:{}, URL:{}", result, url);
                }
            }
            else
            {
                LogFactory.error("checkPay Exception. URL:{}", url);
            }
        }
        catch (Exception e)
        {
            LogFactory.error("", e);
        }
        return "";
    }

    public static String getAccessToken()
    {
        return Access_Token;
    }

    public static class GetResponseData
    {
        public String consumptionState;// inapp产品的消费状态。可能的值是：1:Yet to be consumed;2:消费
        public String developerPayload;// 开发人员指定的字符串，包含有关订单的补充信息。
        public String kind;// 这种类型代表androidpublisher服务中的inappPurchase对象。
        public String orderId;// 与购买inapp产品相关联的订单ID。
        public int purchaseState;// 订单的购买状态。可能的值是 1:购买;2:取消;
        public String purchaseTimeMillis;// 购买产品的时间，自纪元（1970年1月1日）以来的毫秒数。
        public String purchaseType;// 购买inapp产品的类型。仅当未使用标准应用内结算流程进行此购买时，才会设置此字段。可能的值是：1:测试;2:促销;
    }
}
