package com.game.cache;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.base.component.SimpleScheduleComponent;
import com.base.redis.RedisCommon;
import com.base.redis.RedisSaveHandler;
import com.base.rmi.IRemoteCode;
import com.data.business.SystemBusiness;
import com.data.business.TableType;
import com.data.info.TablesInfo;

import it.biobytes.ammentos.PersistenceException;

/**
 * 获得系统配置信息
 * 
 * @author dream
 *
 */
@IRemoteCode(code = GameCacheType.System, desc = "模板数据")
public class RemoteSystem extends RedisCommon
{
    private static final Logger LOGGER = LoggerFactory.getLogger(RemoteSystem.class);

    private static final byte SYSTEM_MAX_ID = 1;

    private static final String KEY_SYSTEM_MAX_ID = "system:%s";

    private static final String KEY_SYSTEM_INFO_MAX_ID = "system_max_info:%d";

    public RemoteSystem()
    {
        RedisSaveHandler<TablesInfo> maxHandler = new RedisSaveHandler<TablesInfo>((list) -> SystemBusiness.updateTablesInfo(list));
        handlerMap.put(SYSTEM_MAX_ID, maxHandler);
    }

    public <T> List<T> getBeanList(Class<T> className)
    {
        try
        {
            // 系统配置信息从数据库加载，不缓存，只在系统启动时加载，不需要缓存
            List<T> list = SystemBusiness.getBeanList(className);

            if (list == null)
            {
                list = new ArrayList<>();
            }

            return list;
        }
        catch (PersistenceException e)
        {
            LOGGER.error("Exception: System Bean Initialized Error - " + className.getName(), e);
        }
        return null;
    }

    public <T> boolean removeData(T data)
    {
        return SystemBusiness.removeData(data);
    }

    public boolean saveData(List<?>... dataList)
    {
        return SystemBusiness.saveData(dataList);
    }

    /**
     * 异步保存到数据库中
     * 
     * @param tableID
     * @param value
     */
    public void asyncMysql(int tableID, long value)
    {
        SimpleScheduleComponent.schedule((job) -> {
            TablesInfo info = new TablesInfo();
            info.setTableID(tableID);
            info.setValue(value);
            String key = String.format(KEY_SYSTEM_INFO_MAX_ID, tableID);
            getRedisClient().setex(key, info);
            addKey(SYSTEM_MAX_ID, 0, key, TablesInfo.class);
        });
    }

    /**
     * 取得最大ID
     * 
     * @param tableID
     * @return
     */
    public long getTableMaxID(TableType tableID)
    {
        String key = String.format(KEY_SYSTEM_MAX_ID, tableID.getValue());
        long val = getRedisClient().incr(key);
        asyncMysql(tableID.getValue(), val);

        return val;
    }

    /**
     * 游戏重启时，判断重置自增值(incr 和 getSet 一对原子操作,设置修改自增值)
     * 1.游戏重启，缓存正常，以缓存为准
     * 2.游戏重启，缓存重启，以最大值为准
     * 3.游戏重启，合服最大值改变，以数据库为准
     * 
     * @param tableID
     * @param maxValue
     */
    public synchronized void resetTableMaxID(int tableID, long maxValue)
    {
        if (maxValue < 10000)
            maxValue = 10000;

        String key = String.format(KEY_SYSTEM_MAX_ID, tableID);
        long val = getRedisClient().incr(key);
        long max = Math.max(val, maxValue);
        // 如果缓存的比数据库的小，重置为数据库的值
        if (val < max)
            getRedisClient().getSet(key, String.valueOf(max + 10));

        asyncMysql(tableID, max + 10);
    }
}
