package com.game;

import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;
import com.google.api.client.http.HttpTransport;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.util.SecurityUtils;

public class GoogleSignInterceptor
{
    private static final String SERVICE_ACCOUNT_EMAIL = "{googlePlay.serviceAccountEmail}";
    private static final String PUBLIC_KEY = "{googlePlay.publicKey}";
    private static final String P12_Key = "/key.p12";

    public Object preHandle(ProceedingJoinPoint proceedingJoinPoint)
    {
        Object[] args = proceedingJoinPoint.getArgs();
        // 获取参数
        String signature = null;
        String purchaseData = null;
        try
        {
            purchaseData = String.valueOf(args[0]);
            signature = String.valueOf(args[1]);
        }
        catch (NullPointerException e)
        {
            logger.error("参数为空");
        }

        // 签名校验
        String publicKey = ConfigManager.getProperty(PUBLIC_KEY);
        try
        {
            boolean isVertify = docheck(purchaseData, signature, publicKey);
            if (isVertify == false)
            {
                logger.error("签名校验失败publicKey:" + publicKey);
            }
        }
        catch (Exception e)
        {
            logger.error("签名校验失败", e);
        }
        // 调用google api二次校验
        com.alibaba.fastjson.JSONObject jsonObject;
        try
        {
            jsonObject = JSON.parseObject(purchaseData);
        }
        catch (JSONException e)
        {
            logger.error("purchaseData解析失败", e);
        }
        String productId = jsonObject.getString("productId");
        String packageName = jsonObject.getString("packageName");
        String purchaseToken = jsonObject.getString("purchaseToken");
        int purchaseState = jsonObject.getIntValue("purchaseState");
        if (purchaseState != 0)
        {
            logger.error("订单未支付!");
        }

        try
        {

            HttpTransport transport = GoogleNetHttpTransport.newTrustedTransport();
            PrivateKey privateKey = SecurityUtils.loadPrivateKeyFromKeyStore(
                    SecurityUtils.getPkcs12KeyStore(),
                    this.getClass().getResourceAsStream(P12_Key), "notasecret",
                    "privatekey", "notasecret");
            GoogleCredential credential = new GoogleCredential.Builder().setTransport(transport).setJsonFactory(JacksonFactory.getDefaultInstance()).setServiceAccountId(
                    SERVICE_ACCOUNT_EMAIL).setServiceAccountScopes(Collections.singleton(AndroidPublisherScopes.ANDROIDPUBLISHER)).setServiceAccountPrivateKey(privateKey).build();
            AndroidPublisher publisher = new AndroidPublisher.Builder(transport,
                    JacksonFactory.getDefaultInstance(), credential).build();
            AndroidPublisher.Purchases.Products products = publisher.purchases().products();
            AndroidPublisher.Purchases.Products.Get product = products.get(packageName, productId, purchaseToken);

            ProductPurchase purchase = product.execute();
            if (purchase.getPurchaseState() != 0)
            {
                logger.error("订单未支付!");
            }
        }
        catch (Exception e)
        {
            logger.error("订单验证失败! ", e);
        }

        try
        {
            return proceedingJoinPoint.proceed();
        }
        catch (Throwable throwable)
        {
            logger.error("系统错误", throwable);

        }
    }

    private boolean docheck(String content, String sign, String publicKey)
            throws Exception
    {
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        byte[] encodedKey = Base64.getDecoder().decode(publicKey);
        PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));
        Signature signature = Signature.getInstance("SHA1WithRSA");
        signature.initVerify(pubKey);
        signature.update(content.getBytes("utf-8"));
        return signature.verify(Base64.getDecoder().decode(sign));
    }
}
