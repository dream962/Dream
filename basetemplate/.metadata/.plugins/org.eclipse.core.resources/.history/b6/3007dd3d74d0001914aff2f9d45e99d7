package com.logic.component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.base.component.AbstractComponent;
import com.logic.game.AbstractGame;
import com.logic.object.AbstractGamePlayer;
import com.logic.room.BaseRoom;
import com.logic.room.RoomStateType;
import com.logic.type.MissionType;
import com.util.print.LogFactory;

/**
 * 房间管理组件,对房间的所有命令操作
 * 
 * @author dream
 * @date 2013-3-10
 * @version
 */
public class RoomComponent extends AbstractComponent
{
    /** 撮合间隔时间(秒) */
    private static final int PICK_UP_INTERVAL = 3;

    /** 撮合线程 */
    private static ScheduledExecutorService singleExecutor;

    /** 本服务器的所有房间对象 */
    private static Map<Integer, BaseRoom> roomMap = new ConcurrentHashMap<>();

    /** 参与匹配的玩家 */
    private static Map<Integer, Map<Long, AbstractGamePlayer>> matchPlayers = new ConcurrentHashMap<>();

    /** 正在使用中的房间数量 */
    private static AtomicInteger roomIndex = new AtomicInteger(0);

    /**
     * 自增创建房间ID
     * 
     * @return
     */
    private static int createRoomID()
    {
        if (roomIndex.get() >= Integer.MAX_VALUE)
            roomIndex.set(0);
        return roomIndex.incrementAndGet();
    }

    @Override
    public boolean initialize()
    {
        singleExecutor = Executors.newSingleThreadScheduledExecutor();
        singleExecutor.scheduleWithFixedDelay(() -> doPickUp(), 3, PICK_UP_INTERVAL, TimeUnit.SECONDS);
        return true;
    }

    @Override
    public boolean start()
    {
        return true;
    }

    @Override
    public void stop()
    {
        roomMap.clear();
        matchPlayers.clear();
    }

    /**
     * 获取指定房间号的房间
     * 
     * @param roomId
     *            房间ID
     * @return id合法时返回对应房间的房间对象，否则返回null
     */
    public static BaseRoom getRoomById(int roomId)
    {
        return roomMap.get(roomId);
    }

    /**
     * 创建游戏房间
     * 
     * @param proxyGamePlayer
     *            玩家对象
     */
    public static BaseRoom createRoom(AbstractGamePlayer player1, AbstractGamePlayer player2, int missionID)
    {
        BaseRoom room = new BaseRoom(createRoomID(), MissionType.Simple.getValue());
        room.setMissionID(missionID);
        room.start();

        if (room.addPlayer(player1))
        {
            roomMap.put(room.getRoomId(), room);
            return room;
        }

        return room;
    }

    public static void removeRoom(int roomId)
    {
        roomMap.remove(roomId);
    }

    protected static void doPickUp()
    {
        try
        {
            long startTick = System.currentTimeMillis();
            pickPVP();
            long endTick = System.currentTimeMillis();

            if (endTick - startTick > 10000)
                LogFactory.warn("Pickup Room spend too much time:" + (endTick - startTick));
        }
        catch (Exception e)
        {
            LogFactory.error("撮合报错", e);
        }
    }

    public static List<BaseRoom> getAllRoom()
    {
        List<BaseRoom> list = new ArrayList<>();
        list.addAll(roomMap.values());
        return list;
    }

    /**
     * 根据类型取得不同类型房间
     * 
     * @param type
     * @return
     */
    private static List<BaseRoom> getWaitingMatchRoom(int type)
    {
        List<BaseRoom> list = getAllRoom();
        List<BaseRoom> temp = new ArrayList<>();
        for (BaseRoom room : list)
        {
            if (room.getMissionType() == type && room.getRoomStateType() == RoomStateType.Picking && room.getGame() == null)
            {
                temp.add(room);
            }
        }
        return temp;
    }

    private static void pickPVP()
    {
        List<BaseRoom> roomList = getWaitingMatchRoom(MissionType.Simple.getValue());

        synchronized (matchPlayers)
        {
            for (Entry<Integer, Map<Long, AbstractGamePlayer>> players : matchPlayers.entrySet())
            {
                int missionType = players.getKey();
                Map<Long, AbstractGamePlayer> map = players.getValue();

                List<AbstractGamePlayer> matchList = new ArrayList<>(players.getValue().values());

            }
        }

        for (BaseRoom blue : roomList)
        {
            if (blue.getRoomStateType() == RoomStateType.Picking)
            {
                for (BaseRoom red : roomList)
                {
                    if (red != blue && red.getRoomStateType() == RoomStateType.Picking)
                    {
                        List<AbstractGamePlayer> blueTeam = blue.getAllPlayer();
                        List<AbstractGamePlayer> redTeam = red.getAllPlayer();
                        int missionID = red.getMissionID();
                        int gameType = red.getMissionType();
                        AbstractGame game = GameComponent.startPvpGame(gameType, redTeam, blueTeam, missionID);
                        if (game != null)
                        {
                            red.startGame(game);
                            blue.startGame(game);
                        }
                    }
                }
            }
        }
    }

    /**
     * 添加匹配的玩家
     * 
     * @param missionType
     * @param player
     */
    public static void addMatchPlayer(int missionType, AbstractGamePlayer player)
    {
        synchronized (matchPlayers)
        {
            player.getRoomModule().setBeginMatchTime(System.currentTimeMillis());
            matchPlayers.getOrDefault(missionType, new HashMap<>()).put(player.getUserID(), player);
        }
    }

    /**
     * 移除匹配的玩家
     * 
     * @param player
     */
    public static void removeMatchPlayer(AbstractGamePlayer player)
    {
        synchronized (matchPlayers)
        {
            matchPlayers.forEach((k, v) -> {
                v.remove(player.getUserID());
            });
            
            player.getRoomModule().setBeginMatchTime(0);
        }
    }
}
