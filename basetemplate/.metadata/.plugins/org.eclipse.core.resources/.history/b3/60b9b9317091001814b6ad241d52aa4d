package com.logic.map;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import com.util.path.ANode;
import com.util.structure.BinaryHeap;

/**
 * @author dream
 *
 */
public class PathAStar
{
    private BinaryHeap<PathANode> open;
    private List<PathANode> closed;
    private MapGraph nodeGrid;
    private PathANode endNode;
    private PathANode startNode;
    private List<PathANode> path;
    private float straightCost = 1.0f;

    public PathAStar(MapGraph grid)
    {
        nodeGrid = grid;
    }

    public boolean findPath(int begin, int end)
    {
        PathANode beginNode = nodeGrid.getPathNode(begin);
        PathANode endNode = nodeGrid.getPathNode(end);
        open = new BinaryHeap<PathANode>(new Comparator<PathANode>()
        {
            @Override
            public int compare(PathANode o1, PathANode o2)
            {
                return (int) (o1.f - o2.f);
            }
        });
        closed = new ArrayList<PathANode>();

        this.startNode = beginNode;
        this.endNode = endNode;

        startNode.g = 0;
        startNode.h = diagonal(startNode);
        startNode.f = startNode.g + startNode.h;

        return search();
    }

    public boolean search()
    {
        // 异步运算。当上一次遍历超出最大允许值后停止遍历，下一次从上次暂停处开始继续遍历
        PathANode node = startNode;

        while (node != endNode)
        {
            List<PathANode> neightors = node.getNeighbors();
            // 寻找当前节点周围6个点

            for (PathANode test : neightors)
            {
                if (test == node || !test.node.getCanMove())
                {
                    continue;
                }

                float cost = nodeGrid.getCell();
                if (!((node.x == test.x) || (node.y == test.y)))
                    cost = diagCost;

                float g = node.g + cost * test.costMultiplier;
                float h = diagonal(test);
                float f = g + h;
                // 判断是否已经在openList里面
                boolean isInOpen = open.indexOf(test) != -1;
                if (isInOpen || closed.indexOf(test) != -1)
                {
                    if (test.f > f)
                    {
                        test.f = f;
                        test.g = g;
                        test.h = h;
                        test.parent = node;
                        if (isInOpen)
                            open.updateNode(test);
                    }
                }
                else
                {
                    // 加入到openList里面
                    test.f = f;
                    test.g = g;
                    test.h = h;
                    test.parent = node;
                    open.push(test);
                }
            }

            closed.add(node);
            if (open.getSize() == 0)
            {
                return false;
            }

            node = open.pop();
        }
        buildPath();

        return true;
    }

    /**
     * 弗洛伊德路径平滑处理
     * form http://wonderfl.net/c/aWCe
     */
    public void floyd()
    {
        if (path == null)
            return;

        floydPath = new ArrayList<ANode>();
        floydPath.addAll(path);
        int len = floydPath.size();
        if (len > 2)
        {
            ANode vector = new ANode(0, 0);
            ANode tempVector = new ANode(0, 0);
            // 遍历路径数组中全部路径节点，合并在同一直线上的路径节点
            // 假设有1,2,3,三点，若2与1的横、纵坐标差值分别与3与2的横、纵坐标差值相等则
            // 判断此三点共线，此时可以删除中间点2
            floydVector(vector, floydPath.get(len - 1), floydPath.get(len - 2));
            for (int i = floydPath.size() - 3; i >= 0; i--)
            {
                floydVector(tempVector, floydPath.get(i + 1), floydPath.get(i));
                if (vector.x == tempVector.x && vector.y == tempVector.y)
                {
                    floydPath.remove(i + 1);
                }
                else
                {
                    vector.x = tempVector.x;
                    vector.y = tempVector.y;
                }
            }
        }
        // 合并共线节点后进行第二步，消除拐点操作。算法流程如下：
        // 如果一个路径由1-10十个节点组成，那么由节点10从1开始检查
        // 节点间是否存在障碍物，若它们之间不存在障碍物，则直接合并
        // 此两路径节点间所有节点。
        len = floydPath.size();
        for (int i = len - 1; i >= 0; i--)
        {
            for (int j = 0; j <= i - 2; j++)
            {
                if (nodeGrid.hasBarrier(floydPath.get(i).x, floydPath.get(i).y, floydPath.get(j).x, floydPath.get(j).y) == false)
                {
                    for (int k = i - 1; k > j; k--)
                    {
                        floydPath.remove(k);
                    }
                    i = j;
                    len = floydPath.size();
                    break;
                }
            }
        }
    }

    private void buildPath()
    {
        path = new ArrayList<ANode>();
        ANode node = endNode;
        path.add(node);

        while (node != startNode)
        {
            node = node.parent;
            path.add(0, node);
        }
    }

    /**
     * 直线算法,当前点到终点的距离计算
     * 
     * @param node
     * @return
     */
    private float diagonal(PathANode node)
    {
        int disX = node.node.getPX() - endNode.node.getPX();
        int disY = node.node.getPY() - endNode.node.getPY();
        int distance = (int) Math.sqrt(disX * disX + disY * disY);
        return distance;
    }

    /**
     * 没有优化的路径
     * 
     * @return
     */
    public List<PathANode> getPath()
    {
        return path;
    }
}
