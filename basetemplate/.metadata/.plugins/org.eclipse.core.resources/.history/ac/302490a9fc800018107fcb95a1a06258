package io.jpower.kcp.netty;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import com.util.print.LogFactory;

import io.jpower.kcp.netty.internal.ReItrLinkedList;
import io.jpower.kcp.netty.internal.ReusableListIterator;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.util.Recycler;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

/**
 * ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，
 * 以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</br>
 * </br>
 * 
 * KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，
 * 可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。</br>
 * </br>
 * 
 * sn:Sequence Number：32位的序列号标识了报文中第一个byte在对应方向的传输中对应的字节序号
 * ack:Acknowledgment Number 32位的序列号标识报文发送端期望接收的字节序列
 * 
 * @author dream
 *
 */
public class Kcp
{

    private static final InternalLogger log = InternalLoggerFactory.getInstance(Kcp.class);

    /** 快速模式（NoDely）下的RTO时间 */
    public static final int IKCP_RTO_NDL = 30;

    /** RTO正常模式最小超时重传 */
    public static final int IKCP_RTO_MIN = 100;
    /** Retransmission TimeOut 默认超时重传 */
    public static final int IKCP_RTO_DEF = 200;
    /** RTO重传超时时间最大时间 */
    public static final int IKCP_RTO_MAX = 60000;

    /** 协议类型 [正常接收数据] */
    public static final byte IKCP_CMD_PUSH = 81;
    /** 协议类型 [收到ack回复] */
    public static final byte IKCP_CMD_ACK = 82;
    /** 协议类型 [询问对方窗口size] */
    public static final byte IKCP_CMD_WASK = 83;
    /** 协议类型 [告知对方我的窗口size] */
    public static final byte IKCP_CMD_WINS = 84;

    /** 是否需要发送 IKCP_CMD_WASK */
    public static final int IKCP_ASK_SEND = 1;
    /** 是否需要发送 IKCP_CMD_WINS */
    public static final int IKCP_ASK_TELL = 2;

    /** 默认情况下的发送窗口大小（包的数量） */
    public static final int IKCP_WND_SND = 32;
    /** 默认情况下的接收窗口大小（包的数量） */
    public static final int IKCP_WND_RCV = 32;
    /** 默认MTU（最大传输单元）分片的大小 */
    public static final int IKCP_MTU_DEF = 1400;

    /** 没有用到 */
    public static final int IKCP_ACK_FAST = 3;

    /** flush: 控制刷新时间间隔 */
    public static final int IKCP_INTERVAL = 100;
    /** 包头大小 */
    public static final int IKCP_OVERHEAD = 24;
    /** 单个报文重传超过指定次数，视为断线 */
    public static final int IKCP_DEADLINK = 20;
    /** ssthresh: 慢热启动 初始窗口大小 */
    public static final int IKCP_THRESH_INIT = 2;
    /** ssthresh: 慢热启动 最小窗口大小 */
    public static final int IKCP_THRESH_MIN = 2;

    /** 请求询问远端窗口大小的初始时间 7s */
    public static final int IKCP_PROBE_INIT = 7000;
    /** 请求询问远端窗口大小的最大时间 120s */
    public static final int IKCP_PROBE_LIMIT = 120000;

    private static class Segment
    {
        /** */
        private final Recycler.Handle<Segment> recyclerHandle;
        /** conv为一个表示会话编号的整数，和tcp的 conv一样，通信双 方需保证 conv相同，相互的数据包才能够被认可 服务器为当前连接分配的唯一ID */
        private int conv;
        /** cmd用来区分分片的作用。IKCP_CMD_PUSH:数据分片 IKCP_CMD_ACK:ack分片 IKCP_CMD_WASK请求告知窗口大小 IKCP_CMD_WINS:告知窗口大小 */
        private byte cmd;
        /** message中的segment分片ID（在message中的索引，由大到小，0表示最后一个分片） 报文在包中的位置：包被分割成n个报文进行发送， frg = n - index - 1 [倒序索引] */
        private short frg;
        /** 剩余接收窗口大小(接收窗口大小-接收队列大小) 接收窗口未被使用的大小：wnd = rcv_wnd - rcv_queue.Length */
        private int wnd;
        /** message发送时刻的时间戳 报文发送时间 */
        private long ts;
        /** message分片segment的序号； ack命令时：含义是反馈收到的ack报文；正常数据命令：是报文的编号和等待回应的帧ID */
        private long sn;
        /** 待接收消息序号(接收滑动窗口左端) ack当前未应答最小帧号 */
        private long una;
        /** 下一次重传的时间 */
        private long resendts;
        /** 超时重传机制的时间系数，会动态调整 */
        private int rto;
        /** 这个值会累加，当超过一个阈值的时候会触发一次重传。累计规则：收到比它后的帧号的ack应答后，它会被累加 */
        private int fastack;
        /** 重传次数，当xmit > dead_link 表示连接断开 */
        private int xmit;
        /** 数据 */
        private ByteBuf data;

        private static final Recycler<Segment> RECYCLER = new Recycler<Segment>()
        {
            @Override
            protected Segment newObject(Handle<Segment> handle)
            {
                return new Segment(handle);
            }
        };

        private Segment(Recycler.Handle<Segment> recyclerHandle)
        {
            this.recyclerHandle = recyclerHandle;
        }

        void recycle(boolean releaseBuf)
        {
            conv = 0;
            cmd = 0;
            frg = 0;
            wnd = 0;
            ts = 0;
            sn = 0;
            una = 0;
            resendts = 0;
            rto = 0;
            fastack = 0;
            xmit = 0;
            if (releaseBuf)
            {
                data.release();
            }
            data = null;

            recyclerHandle.recycle(this);
        }

        static Segment createSegment(ByteBufAllocator byteBufAllocator, int size)
        {
            Segment seg = RECYCLER.get();
            if (size == 0)
            {
                seg.data = byteBufAllocator.ioBuffer(0, 0);
            }
            else
            {
                seg.data = byteBufAllocator.ioBuffer(size);
            }
            return seg;
        }

        static Segment createSegment(ByteBuf buf)
        {
            Segment seg = RECYCLER.get();
            seg.data = buf;
            return seg;
        }

    }

    /** 会话编号 */
    private int conv;
    /** MTU（最大传输单元）分片的大小 */
    private int mtu = IKCP_MTU_DEF;
    /** 单个包体的大小（MTU-包头） */
    private int mss = this.mtu - IKCP_OVERHEAD;
    /** 描述连接是否死亡的状态 */
    private int state;

    /** 发送队列里的数据，等待ack回应的最小帧号 */
    private long sndUna;
    /** 发送队列下一个待发送的帧号 */
    private long sndNxt;
    /** 接收队列下一个待接收的帧号：相当于rcvQueue队列里面的指针，当数据从rcvBuf转移到rcvQueue后，revNxt就累加 */
    private long rcvNxt;

    /** 慢热启动窗口大小 */
    private int ssthresh = IKCP_THRESH_INIT;

    /** */
    private int rxRttval;
    /** */
    private int rxSrtt;

    /** 重传超时时间 */
    private int rxRto = IKCP_RTO_DEF;
    /**
     * 当前KCP里面的RTO的时间 - 不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的
     * RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值
     */
    private int rxMinrto = IKCP_RTO_MIN;

    /** 发送窗口大小 */
    private int sndWnd = IKCP_WND_SND;
    /** 接收窗口大小 */
    private int rcvWnd = IKCP_WND_RCV;
    /** 远端接收窗口大小 */
    private int rmtWnd = IKCP_WND_RCV;
    /** 窗口大小 */
    private int cwnd;
    /** 请求窗口size | 发送窗口size */
    private int probe;
    /** 当前Update时间 */
    private long current;
    /** 刷新间隔时间 */
    private int interval = IKCP_INTERVAL;
    /** 上一次flush的时间 */
    private long tsFlush = IKCP_INTERVAL;
    /** 无延迟模式系数 */
    private boolean nodelay;
    /** 是否是第一次更新 */
    private boolean updated;
    /** 下一次请求探测远端窗口大小的时间 */
    private long tsProbe;
    /** 探测等待时间，一个动态调整的值 */
    private int probeWait;
    /** 超时重传超过这个值，视作连接断开 */
    private int deadLink = IKCP_DEADLINK;
    /** 慢热启动 */
    private int incr;

    /**
     * 当你持续调用 ikcp_send，首先会填满kcp的 sndBuf，如果 sndBuf 的大小超过发送窗口 snd_wnd 限制，则会停止向 sndBuf 里追加 数据包，
     * 只会放在 sndQueue 里面滞留着，等待 sndBuf 有新位置了（因为收到远端 ack/una而将历史包从 sndBuf中移除），才会从 sndQueue 转移到 sndBuf，等待发送。
     */
    private ReItrLinkedList<Segment> sndBuf = new ReItrLinkedList<>();
    /** 发送数据队列 */
    private LinkedList<Segment> sndQueue = new LinkedList<>();

    /** 接收的缓存数据队列，接收到的数据先保存在这里，然后移动到rcvQueue队列里，如果接收队列满了（达到接收窗口大小），数据就暂存在rcvBuf里保存，直到queue队列里有空间 */
    private ReItrLinkedList<Segment> rcvBuf = new ReItrLinkedList<>();
    /** 接收数据的真正队列，如果队列大小超过接收窗口大小，就暂时不接收，直到处理后有空间才接收 */
    private ReItrLinkedList<Segment> rcvQueue = new ReItrLinkedList<>();

    /** 接收真正队列的迭代器 */
    private ReusableListIterator<Segment> rcvQueueItr = rcvQueue.listIterator();
    /** 发送队列的迭代器 */
    private ReusableListIterator<Segment> sndBufItr = sndBuf.listIterator();
    /** 接收缓存队列的迭代器 */
    private ReusableListIterator<Segment> rcvBufItr = rcvBuf.listIterator();

    /** 待返回的ack应答序列 添加时如果数组长度不足会扩容 偶数：对方发送的sn，待返回的ack；奇数：发送的时间 */
    private int[] acklist = new int[8];
    /** 收到的ack数量 */
    private int ackcount;
    /** Channel实例 */
    private Object user;
    /** 快速重传 */
    private int fastresend;
    /** 是否不同步当前滑动窗口的大小，如果false,发送窗口大小时，去本地能接收的窗口大小 */
    private boolean nocwnd;

    /** 是否是流模式 */
    private boolean stream;
    /** 真正发送的函数 */
    private KcpOutput output;

    /** buffer分配器 */
    private ByteBufAllocator byteBufAllocator = ByteBufAllocator.DEFAULT;

    /** 是否自动设置回话编号 */
    private boolean autoSetConv;

    private static long long2Uint(long n)
    {
        return n & 0x00000000FFFFFFFFL;
    }

    private static int ibound(int lower, int middle, int upper)
    {
        return Math.min(Math.max(lower, middle), upper);
    }

    /**
     * 返回两个时间的间隔
     * 
     * @param later
     * @param earlier
     * @return
     */
    private static int itimediff(long later, long earlier)
    {
        return (int) (later - earlier);
    }

    private static void output(ByteBuf data, Kcp kcp)
    {
        if (data.readableBytes() == 0)
        {
            return;
        }

        if (log.isDebugEnabled())
        {
            log.debug("{} kcp发送数据包。大小： {} bytes", kcp, data.readableBytes());
        }

        kcp.output.out(data, kcp);
    }

    /**
     * 装填segment信息到buffer里
     * 
     * @param buf
     * @param seg
     * @return
     */
    private static int encodeSeg(ByteBuf buf, Segment seg)
    {
        int offset = buf.writerIndex();

        buf.writeIntLE(seg.conv);
        buf.writeByte(seg.cmd);
        buf.writeByte(seg.frg);
        buf.writeShortLE(seg.wnd);
        buf.writeIntLE((int) seg.ts);
        buf.writeIntLE((int) seg.sn);
        buf.writeIntLE((int) seg.una);
        buf.writeIntLE(seg.data.readableBytes());

        return buf.writerIndex() - offset;
    }

    public Kcp(int conv, KcpOutput output)
    {
        this.conv = conv;
        this.output = output;
    }

    public void release()
    {
        release(sndBuf);
        release(rcvBuf);
        release(sndQueue);
        release(rcvQueue);
    }

    private void release(List<Segment> segQueue)
    {
        for (Segment seg : segQueue)
        {
            seg.recycle(true);
        }
    }

    private ByteBuf createByteBuf()
    {
        return byteBufAllocator.ioBuffer((this.mtu + IKCP_OVERHEAD) * 3);
    }

    public int recv(List<ByteBuf> bufList)
    {
        // 1.判断是否有数据返回，先从rcvQueue里面查找封装好的数据
        if (rcvQueue.isEmpty())
        {
            // 接收队列为空，当前没有数据可以返回
            return -1;
        }

        int peekSize = peekSize();
        // 当前没有完整的包返回
        if (peekSize < 0)
        {
            return -2;
        }

        // 接收队列大于滑动窗口的size，触发快速发送我的窗口size给远端
        boolean recover = false;
        if (rcvQueue.size() >= rcvWnd)
        {
            recover = true;
        }

        // 2.拷贝rcv_queue到buffer，直到 frg = 0
        int len = 0;
        for (Iterator<Segment> itr = rcvQueueItr.rewind(); itr.hasNext();)
        {
            Segment seg = itr.next();
            len += seg.data.readableBytes();
            bufList.add(seg.data);

            int fragment = seg.frg;

            // log
            if (log.isDebugEnabled())
            {
                log.debug("{} recv sn={}", this, seg.sn);
            }

            itr.remove();
            seg.recycle(false);

            if (fragment == 0)
            {
                break;
            }
        }

        assert len == peekSize;

        // move available data from rcv_buf -> rcv_queue
        moveRcvData();

        // fast recover
        if (rcvQueue.size() < rcvWnd && recover)
        {
            // ready to send back IKCP_CMD_WINS in ikcp_flush
            // tell remote my window size
            probe |= IKCP_ASK_TELL;
        }

        return len;
    }

    /**
     * 检测是否有完整的包，返回包的长度,-1 表示没有
     * 
     * @return
     */
    public int peekSize()
    {
        // 1.接收队列为空
        if (rcvQueue.isEmpty())
        {
            return -1;
        }
        // 2.当 frg = 0 表示已经接收到包的最后一个报文
        Segment seg = rcvQueue.peek();
        if (seg.frg == 0)
        {
            return seg.data.readableBytes();
        }

        // 3.接收队列的大小 小于 包的总报文数量，肯定不够
        if (rcvQueue.size() < seg.frg + 1)
        {
            return -1;
        }

        // 4.计算一个完整包的长度
        int len = 0;
        for (Iterator<Segment> itr = rcvQueueItr.rewind(); itr.hasNext();)
        {
            Segment s = itr.next();
            len += s.data.readableBytes();
            // 当 frg = 0 为最后一个报文
            if (s.frg == 0)
            {
                break;
            }
        }

        return len;
    }

    /**
     * 判断是否还有接收到的数据发送到上层逻辑去处理
     * 
     * @return
     */
    public boolean canRecv()
    {
        if (rcvQueue.isEmpty())
        {
            return false;
        }

        // 如果frg==0：大包数据分帧的判断，如果==0说明分帧的包都接收到了，上层逻辑可以处理了
        Segment seg = rcvQueue.peek();
        if (seg.frg == 0)
        {
            return true;
        }

        // 如果剩余的队列size，不够分帧数量的数量，还有数据分帧包没有收到，返回false
        if (rcvQueue.size() < seg.frg + 1)
        {
            return false;
        }

        return true;
    }

    /**
     * 发送数据（上层逻辑传入的buffer）
     * 需要根据mtu拆分包的大小
     * 
     * @param buf
     * @return
     */
    public int send(ByteBuf buf)
    {
        assert mss > 0;
        // 1.计算拆分的报文数 count
        int len = buf.readableBytes();
        if (len == 0)
        {
            // 如果buffer为空，返回
            return -1;
        }

        // 流模式的处理 append to previous segment in streaming mode (if possible)
        if (stream)
        {
            if (!sndQueue.isEmpty())
            {
                Segment last = sndQueue.peekLast();
                if (len < mss)
                {
                    ByteBuf lastData = last.data;
                    int capacity = mss - lastData.readableBytes();
                    int extend = len < capacity ? len : capacity;
                    if (lastData.maxWritableBytes() < extend)
                    { // extend
                        ByteBuf newBuf = byteBufAllocator.ioBuffer(lastData.readableBytes() + extend);
                        newBuf.writeBytes(lastData);
                        lastData.release();
                        lastData = last.data = newBuf;
                    }
                    lastData.writeBytes(buf, extend);

                    len = buf.readableBytes();
                    if (len == 0)
                    {
                        return 0;
                    }
                }
            }
        }

        int count = 0;

        if (len <= mss)
        {
            // 如果数据长度小于包体的长度
            count = 1;
        }
        else
        {
            // 计算拆分个数
            count = (len + mss - 1) / mss;
        }

        // 数量超过255，返回异常
        if (count > 255)
        { // Maybe don't need the conditon in stream mode
            return -2;
        }

        if (count == 0)
        {
            count = 1;
        }

        // 2.把 buff 转换成 segment 保存到snd_queue
        for (int i = 0; i < count; i++)
        {
            int size = len > mss ? mss : len;
            Segment seg = Segment.createSegment(buf.readRetainedSlice(size));
            // 如果数据超过MTU，计算分帧的标识位，从后往前标记
            seg.frg = (short) (stream ? 0 : count - i - 1);
            sndQueue.add(seg);
            len = buf.readableBytes();
        }

        return 0;
    }

    
    /**
     * rtt算法：调整rto的大小 [超时重传]
     * 
     * @param rtt
     */
    private void updateAck(int rtt)
    {
        if (rxSrtt == 0)
        {
            rxSrtt = rtt;
            rxRttval = rtt / 2;
        }
        else
        {
            int delta = rtt - rxSrtt;
            if (delta < 0)
            {
                delta = -delta;
            }
            rxRttval = (3 * rxRttval + delta) / 4;
            rxSrtt = (7 * rxSrtt + rtt) / 8;
            if (rxSrtt < 1)
            {
                rxSrtt = 1;
            }
        }
        int rto = rxSrtt + Math.max(interval, 4 * rxRttval);
        rxRto = ibound(rxMinrto, rto, IKCP_RTO_MAX);
    }

    
    /**
     * 更新snd_una-最小待确认帧号
     * 如果发送队列有数据，设置为第一个待发送的sn
     * 如果没有，重置为sndNxt
     */
    private void shrinkBuf()
    {
        if (sndBuf.size() > 0)
        {
            Segment seg = sndBuf.peek();
            sndUna = seg.sn;
        }
        else
        {
            sndUna = sndNxt;
        }
    }

    /**
     * 根据收到的反馈una，移除发送队列里面的已经被接收的数据
     * 
     * @param una：ack当前未应答最小帧号，即远端当前una以前的数据都接收到了
     */
    private void parseUna(long una)
    {
        for (Iterator<Segment> itr = sndBufItr.rewind(); itr.hasNext();)
        {
            Segment seg = itr.next();
            if (una > seg.sn)
            {
                itr.remove();
                seg.recycle(true);
            }
            else
            {
                break;
            }
        }
    }

    /**
     * 把收到ack反馈报文从snd_buf队列中移除
     * 
     * @param ack
     */
    private void parseAck(long ack)
    {
        // 1.如果ack<snd_una，说明是一个重复ack包， ack>=snd_nxt，说明ack是错的，因为还没有发就收到确认ack，
        if (ack < sndUna || ack >= sndNxt)
        {
            return;
        }

        // 2.把已经应答的内容，从sndBuf里面移出
        for (Iterator<Segment> itr = sndBufItr.rewind(); itr.hasNext();)
        {
            Segment seg = itr.next();
            if (ack == seg.sn)
            {
                itr.remove();
                seg.recycle(true);
                break;
            }

            // 优化效率，如果发送的sn比ack大，之后的就不用判断了
            if (seg.sn > ack)
            {
                break;
            }
        }
    }

    /**
     * 把收到ack的报文，更新 根据ack快速重传算法的fastack
     * 
     * @param sn
     */
    private void parseFastAck(long ack)
    {
        // 1.如果ack<snd_una，说明是一个重复ack包， ack>=snd_nxt，说明ack是错的，因为还没有发就收到确认ack，
        if (ack < sndUna || ack >= sndNxt)
        {
            return;
        }

        for (Iterator<Segment> itr = sndBufItr.rewind(); itr.hasNext();)
        {
            Segment seg = itr.next();
            // 只更新sn小于ack的报文数据，当sn>ack时，就跳出，之后的还不到时候
            if (ack < seg.sn)
            {
                break;
            }
            else if (ack != seg.sn)
            {
                seg.fastack++;// 增加ack的权重
            }
        }
    }

    /**
     * ack数据添加，会对acklist数组扩容
     * 
     * @param sn：对方报文发送的sn
     * @param ts
     *            对方报文发送的时间
     */
    private void ackPush(long sn, long ts)
    {
        int newSize = 2 * (ackcount + 1);

        if (newSize > acklist.length)
        {
            int newCapacity = acklist.length << 1; // double capacity

            if (newCapacity < 0)
            {
                throw new OutOfMemoryError();
            }

            int[] newArray = new int[newCapacity];
            System.arraycopy(acklist, 0, newArray, 0, acklist.length);
            this.acklist = newArray;
        }

        acklist[2 * ackcount] = (int) sn;
        acklist[2 * ackcount + 1] = (int) ts;
        ackcount++;
    }

    /**
     * 把报文放入 rcv_buf
     * 
     * @param newSeg
     */
    private void parseData(Segment newSeg)
    {
        long sn = newSeg.sn;

        // 超出窗口，或者重复消息都会被丢弃
        if (sn >= rcvNxt + rcvWnd || sn < rcvNxt)
        {
            newSeg.recycle(true);
            return;
        }

        // 1.查询报文的位置
        boolean repeat = false;
        boolean findPos = false;
        ListIterator<Segment> listItr = null;
        if (rcvBuf.size() > 0)
        {
            listItr = rcvBufItr.rewind(rcvBuf.size());
            while (listItr.hasPrevious())
            {
                Segment seg = listItr.previous();
                if (seg.sn == sn)
                {
                    repeat = true;
                    break;
                }

                if (sn > seg.sn)
                {
                    findPos = true;
                    break;
                }
            }
        }

        // 2.插入到指定位置
        if (repeat)
        {
            // 如果重复了，回收
            newSeg.recycle(true);
        }
        else if (listItr == null)
        {
            // 列表为空，插入头部
            rcvBuf.add(newSeg);
        }
        else
        {
            // 如果找到了位置，插入到对应位置
            if (findPos)
            {
                listItr.next();
            }

            // 插入到查找的位置
            listItr.add(newSeg);
        }

        // 移动数据 from rcv_buf -> rcv_queue
        moveRcvData(); // Invoke the method only if the segment is not repeat?
    }

    /**
     * 移动发送数据从rcvBuf -> rcvQueue：直到碰到缺口，或窗口变满
     */
    private void moveRcvData()
    {
        for (Iterator<Segment> itr = rcvBufItr.rewind(); itr.hasNext();)
        {
            Segment seg = itr.next();
            // 当接收窗口没有满，并且还有没移除的报文包时
            if (seg.sn == rcvNxt && rcvQueue.size() < rcvWnd)
            {
                itr.remove();
                rcvQueue.add(seg);
                rcvNxt++;
            }
            else
            {
                break;
            }
        }
    }

    /**
     * 处理接收到的报文
     * 1.检查数据是否合法
     * 2.根据收到的sna移除发送队列里已经收到的数据
     * 
     * @param data
     * @return -1：conv不合法 -2：报文体内容为0 -3：cmd类型不对
     */
    public int input(ByteBuf data)
    {
        long oldSndUna = sndUna;
        // 当前接收的最大ack
        long maxack = 0;
        // 是否有更新ack
        boolean flag = false;

        if (log.isDebugEnabled())
        {
            log.debug("{} kcp接收到的数据。 大小：{} bytes", this, data.readableBytes());
        }

        // 包的数据太小
        if (data == null || data.readableBytes() < IKCP_OVERHEAD)
        {
            return -1;
        }

        while (true)
        {
            // 1.获取报文内容
            int conv, len, wnd;
            long ts, sn, una;
            byte cmd;
            short frg;
            Segment seg;

            // 1.1 判断大小是否够一个最小报文
            if (data.readableBytes() < IKCP_OVERHEAD)
            {
                break;
            }
            // 1.2 即便大小够，也不一定是一个报文，需要判断 conv 值
            conv = data.readIntLE();
            if (conv != this.conv && !(this.conv == 0 && autoSetConv))
            {
                return -4;
            }

            cmd = data.readByte();
            frg = data.readUnsignedByte();
            wnd = data.readUnsignedShortLE();
            ts = data.readUnsignedIntLE();
            sn = data.readUnsignedIntLE();
            una = data.readUnsignedIntLE();
            len = data.readIntLE();

            // 1.3 大小不一致
            if (data.readableBytes() < len)
            {
                return -2;
            }

            // 1.4 协议类型不对
            if (cmd != IKCP_CMD_PUSH && cmd != IKCP_CMD_ACK && cmd != IKCP_CMD_WASK && cmd != IKCP_CMD_WINS)
            {
                return -3;
            }

            // 自动设置回话编号
            if (this.conv == 0 && autoSetConv)
            {
                this.conv = conv;
            }

            this.rmtWnd = wnd;
            parseUna(una);      // 移除发送队列里面的已经被接收的数据
            shrinkBuf();        // 重置更新最小待确认帧号-snd_una

            // 是否包里面有包体数据
            boolean readed = false;
            long uintCurrent = long2Uint(current);

            // 1.5 基于协议内容处理报文
            switch (cmd)
            {
            case IKCP_CMD_ACK:// 收到反馈ack的命令
            {
                // 根据当前时间-发送的时间，处理rto时间
                int rtt = itimediff(uintCurrent, ts);
                if (rtt >= 0)
                {
                    updateAck(rtt);     // 调整 rto
                }
                parseAck(sn);       // 根据收到的ack，更新删除发送队列里编号sn的报文数据
                shrinkBuf();        // 重置更新最小待确认帧号-snd_una（这里并不一定真正会更新）

                if (!flag)
                {
                    flag = true;
                    maxack = sn;
                }
                else
                {
                    if (sn > maxack)
                    {
                        maxack = sn;
                    }
                }

                if (log.isDebugEnabled())
                {
                    log.debug("{} 收到远端反馈的ack : ack={}, 数据包来回时间-rtt={}, 当前重传超时时间-rto={}", this, sn, rtt, rxRto);
                }
                break;
            }
            case IKCP_CMD_PUSH:// 1.5.1 处理普通数据报文
            {
                // 接收的报文数据ID 必须小于当前最小接收的ID+接收窗口，不会超过这个范围，如果超过数据是不正确的。
                if (sn < rcvNxt + rcvWnd)
                {
                    // 添加收到的报文ID到反馈ack列表中
                    ackPush(sn, ts);

                    // 只接收sn编号比最小接收ID大的数据，因为小的已经加入了，不用重复加
                    if (sn >= rcvNxt)
                    {
                        // 封报文包
                        if (len > 0)
                        {
                            seg = Segment.createSegment(data.readRetainedSlice(len));
                            readed = true;
                        }
                        else
                        {
                            seg = Segment.createSegment(byteBufAllocator, 0);
                        }
                        seg.conv = conv;
                        seg.cmd = cmd;
                        seg.frg = frg;
                        seg.wnd = wnd;
                        seg.ts = ts;
                        seg.sn = sn;
                        seg.una = una;

                        // 添加接收的数据到接收队列里面
                        parseData(seg);
                    }
                }
                if (log.isDebugEnabled())
                {
                    log.debug("{} 接收到正常数据包: 包的ID-sn={}, ack 当前未应答最小帧号-una={}, 远端发送时间-ts={}", this, sn, una, ts);
                }
                break;
            }
            case IKCP_CMD_WASK:
            {
                // ready to send back IKCP_CMD_WINS in ikcp_flush
                // tell remote my window size
                probe |= IKCP_ASK_TELL; // 远端请求窗口size，把状态置为发送size
                if (log.isDebugEnabled())
                {
                    log.debug("{} 远端询问当前窗口大小。", this);
                }
                break;
            }
            case IKCP_CMD_WINS:
            {
                // do nothing
                if (log.isDebugEnabled())
                {
                    log.debug("{} input tell: {}", this, wnd);
                }
                break;
            }
            default:
                return -3;
            }

            // 如果包体有数据，要跳过，因为之前读取过了
            if (!readed)
            {
                data.skipBytes(len);
            }
        }

        // 如果有更新过ack，重新更新fastAckd的权重
        if (flag)
        {
            parseFastAck(maxack);
        }

        // 1.6 慢热启动
        if (itimediff(sndUna, oldSndUna) > 0)
        {
            if (cwnd < rmtWnd)
            {
                int mss = this.mss;
                if (cwnd < ssthresh)
                {
                    cwnd++;
                    incr += mss;
                }
                else
                {
                    if (incr < mss)
                    {
                        incr = mss;
                    }
                    incr += (mss * mss) / incr + (mss / 16);
                    if ((cwnd + 1) * mss <= incr)
                    {
                        cwnd++;
                    }
                }
                if (cwnd > rmtWnd)
                {
                    cwnd = rmtWnd;
                    incr = rmtWnd * mss;
                }
            }
        }

        return 0;
    }

    /**
     * 当前接收窗口能用的大小
     * 
     * @return
     */
    private int wndUnused()
    {
        if (rcvQueue.size() < rcvWnd)
        {
            return rcvWnd - rcvQueue.size();
        }
        return 0;
    }

    /**
     * 刷新数据
     * 1.发送ack：发送给远端已经接收到的sn数据。
     * 2.发送正常数据：发送发送列表里面的数据到远端
     */
    private void flush()
    {
        long current = this.current;
        long uintCurrent = long2Uint(current);

        // 'ikcp_update' haven't been called.
        if (!updated)
        {
            return;
        }

        Segment seg = Segment.createSegment(byteBufAllocator, 0);
        seg.conv = conv;
        seg.cmd = IKCP_CMD_ACK;
        seg.frg = 0;
        seg.wnd = wndUnused();
        seg.una = rcvNxt;
        seg.sn = 0;
        seg.ts = 0;

        ByteBuf buffer = createByteBuf();

        // 1.ACK返回：应答反馈给对方端已经接收到的报文
        int count = ackcount;
        for (int i = 0; i < count; i++)
        {
            // 判断是否还能填满一个包的大小，如果不能，输出发送
            if (buffer.readableBytes() + IKCP_OVERHEAD > mtu)
            {
                output(buffer, this);
                buffer = createByteBuf();
            }
            seg.sn = acklist[i * 2];// 接收到的对方sn
            seg.ts = acklist[i * 2 + 1];// 接收时的时间
            encodeSeg(buffer, seg);
            if (log.isDebugEnabled())
            {
                log.debug("{} 返回已经接收到的包信息 ack: sn={}, ts={}", this, seg.sn, seg.ts);
            }
        }

        // 重置ack的数量
        ackcount = 0;

        // 询问对端窗口大小 probe window size (if remote window size equals zero)
        if (rmtWnd == 0)
        {
            if (probeWait == 0)
            {
                probeWait = IKCP_PROBE_INIT;
                tsProbe = current + probeWait;
            }
            else
            {
                if (itimediff(current, tsProbe) >= 0)
                {
                    if (probeWait < IKCP_PROBE_INIT)
                    {
                        probeWait = IKCP_PROBE_INIT;
                    }
                    probeWait += probeWait / 2;
                    if (probeWait > IKCP_PROBE_LIMIT)
                    {
                        probeWait = IKCP_PROBE_LIMIT;
                    }
                    tsProbe = current + probeWait;
                    probe |= IKCP_ASK_SEND;
                }
            }
        }
        else
        {
            tsProbe = 0;
            probeWait = 0;
        }

        // flush window probing commands
        if ((probe & IKCP_ASK_SEND) != 0)
        {
            seg.cmd = IKCP_CMD_WASK;
            if (buffer.readableBytes() + IKCP_OVERHEAD > mtu)
            {
                output(buffer, this);
                buffer = createByteBuf();
            }
            encodeSeg(buffer, seg);
            if (log.isDebugEnabled())
            {
                log.debug("{} flush ask", this);
            }
        }

        // flush window probing commands
        if ((probe & IKCP_ASK_TELL) != 0)
        {
            seg.cmd = IKCP_CMD_WINS;
            if (buffer.readableBytes() + IKCP_OVERHEAD > mtu)
            {
                output(buffer, this);
                buffer = createByteBuf();
            }
            encodeSeg(buffer, seg);
            if (log.isDebugEnabled())
            {
                log.debug("{} flush tell: wnd={}", this, seg.wnd);
            }
        }

        probe = 0;

        // 计算远端接收窗口的大小
        int cwnd0 = Math.min(sndWnd, rmtWnd);
        if (!nocwnd)
        {
            cwnd0 = Math.min(this.cwnd, cwnd0);
        }

        // 转移发送数据：从 发送缓存队列-sndQueue 到 发送队列-sndBuf
        while (itimediff(sndNxt, sndUna + cwnd0) < 0)
        {
            Segment newSeg = sndQueue.poll();
            if (newSeg == null)
            {
                break;
            }

            sndBuf.add(newSeg);

            newSeg.conv = conv;
            newSeg.cmd = IKCP_CMD_PUSH;
            newSeg.wnd = seg.wnd;
            newSeg.ts = uintCurrent;
            newSeg.sn = sndNxt++;
            newSeg.una = rcvNxt;
            newSeg.resendts = current;
            newSeg.rto = rxRto;
            newSeg.fastack = 0;
            newSeg.xmit = 0;
        }

        // 超时重传处理
        // calculate resent
        int resent = fastresend > 0 ? fastresend : Integer.MAX_VALUE;
        int rtomin = nodelay ? 0 : (rxRto >> 3);

        // 发送 发送列表里面的数据
        int change = 0;
        boolean lost = false;
        for (Iterator<Segment> itr = sndBufItr.rewind(); itr.hasNext();)
        {
            Segment segment = itr.next();
            boolean needsend = false;
            if (segment.xmit == 0)      // 满足条件：一次都没重发
            {
                needsend = true;
                segment.xmit++;
                segment.rto = rxRto;
                // 计算下次重传时间
                segment.resendts = current + segment.rto + rtomin;
                if (log.isDebugEnabled())
                {
                    log.debug("{} 发送： 发送队列-sndBuf里面的报文: 报文的标识-sn={},下次重传的时间-resendts={}", this, segment.sn, (segment.resendts - current));
                }
            }
            else if (itimediff(current, segment.resendts) >= 0)     // 满足条件：当前时间超过重发时间
            {
                needsend = true;
                segment.xmit++;
                if (!nodelay)
                {
                    segment.rto = rxRto;
                }
                else
                {
                    segment.rto = rxRto / 2;
                }
                segment.resendts = current + segment.rto;

                lost = true;
                if (log.isDebugEnabled())
                {
                    log.debug("{} 报文超时重发. 报文的标识-sn={}, 报文的重发次数-xmit={}, 下次重传的时间-resendts={}", this, segment.sn, segment.xmit,
                            (segment.resendts - current));
                }
            }
            else if (segment.fastack >= resent)     // 满足条件：fastack 超过重传阈值
            {
                needsend = true;
                segment.xmit++;
                LogFactory.error("重传累加次数 fastAck：{},{} - {}", conv, segment, segment.xmit);
                segment.fastack = 0;
                segment.resendts = current + segment.rto;
                change++;
                if (log.isDebugEnabled())
                {
                    log.debug("{} 报文ack超过次数重发。. 报文的标识-sn={}, 报文的重发次数-xmit={}, 下次重传的时间-resendts={} ", this, segment.sn, segment.xmit,
                            (segment.resendts - current));
                }
            }

            // 重传操作
            if (needsend)
            {
                segment.ts = uintCurrent;
                segment.wnd = seg.wnd;
                segment.una = rcvNxt;

                ByteBuf segData = segment.data;
                int segLen = segData.readableBytes();
                int need = IKCP_OVERHEAD + segLen;

                // 判断是否超过mtu
                if (buffer.readableBytes() + need > mtu)
                {
                    output(buffer, this);
                    buffer = createByteBuf();
                }

                encodeSeg(buffer, segment);

                if (segLen > 0)
                {
                    // don't increases data's readerIndex, because the data may be resend.
                    buffer.writeBytes(segData, segData.readerIndex(), segLen);
                }

                // 单个报文重传超过指定次数，视为断线
                if (segment.xmit >= deadLink)
                {
                    state = -1;
                    LogFactory.error("重传超过指定次数：conv:{},重传次数：{} - 报文：{}", conv, segment.xmit, segment);
                }
            }
        }

        // flash remain segments
        if (buffer.readableBytes() > 0)
        {
            output(buffer, this);
        }
        else
        {
            buffer.release();
        }

        seg.recycle(true);

        // 如果是超过fastAck方式重发，慢热算法计算
        if (change > 0)
        {
            int inflight = (int) (sndNxt - sndUna);
            ssthresh = inflight / 2;
            if (ssthresh < IKCP_THRESH_MIN)
            {
                ssthresh = IKCP_THRESH_MIN;
            }
            cwnd = ssthresh + resent;
            incr = cwnd * mss;
        }

        // 如果是超时重发，慢热算法计算
        if (lost)
        {
            ssthresh = cwnd0 / 2;
            if (ssthresh < IKCP_THRESH_MIN)
            {
                ssthresh = IKCP_THRESH_MIN;
            }
            cwnd = 1;
            incr = mss;
        }

        if (cwnd < 1)
        {
            cwnd = 1;
            incr = mss;
        }
    }

    /**
     * update getState (call it repeatedly, every 10ms-100ms), or you can ask
     * ikcp_check when to call it again (without ikcp_input/_send calling).
     * 'current' - current timestamp in millisec.
     *
     * @param current
     */
    public void update(long current)
    {
        this.current = current;

        // 第一次处理
        if (!updated)
        {
            updated = true;
            tsFlush = this.current;
        }

        int slap = itimediff(this.current, tsFlush);
        // 超时处理
        if (slap >= 10000 || slap < -10000)
        {
            tsFlush = this.current;
            slap = 0;
        }

        // 利用 ts_flush 控制刷新的时间间隔，interval 控制频率
        if (slap >= 0)
        {
            tsFlush += interval;
            if (itimediff(this.current, tsFlush) >= 0)
            {
                tsFlush = this.current + interval;
            }
        }
        else
        {
            tsFlush = this.current + interval;
        }
        flush();
    }

    
    /**
     * 检测是否需要立即刷新
     * Determine when should you invoke ikcp_update:
     * returns when you should invoke ikcp_update in millisec, if there
     * is no ikcp_input/_send calling. you can call ikcp_update in that
     * time, instead of call update repeatly.
     * Important to reduce unnacessary ikcp_update invoking. use it to
     * schedule ikcp_update (eg. implementing an epoll-like mechanism,
     * or optimize ikcp_update when handling massive kcp connections)
     *
     * @param current
     * @return
     */
    public long check(long current)
    {
        if (!updated)
        {
            return current;
        }

        long tsFlush = this.tsFlush;
        int slap = itimediff(current, tsFlush);
        // 1.如果超时，立即刷新
        if (slap >= 10000 || slap < -10000)
        {
            tsFlush = current;
            slap = 0;
        }

        // 2.如果超过了应该刷新的时间，立即刷新
        if (slap >= 0)
        {
            return current;
        }

        int tmFlush = itimediff(tsFlush, current);
        int tmPacket = Integer.MAX_VALUE;

        // 3.如果有需要超时重传的报文，立即刷新
        for (Iterator<Segment> itr = sndBufItr.rewind(); itr.hasNext();)
        {
            Segment seg = itr.next();
            int diff = itimediff(seg.resendts, current);
            if (diff <= 0)
            {
                return current;
            }
            if (diff < tmPacket)
            {
                tmPacket = diff;
            }
        }

        // 4.计算最终下一次更新的时间
        int minimal = tmPacket < tmFlush ? tmPacket : tmFlush;
        if (minimal >= interval)
        {
            minimal = interval;
        }

        return current + minimal;
    }

    
    public boolean checkFlush()
    {
        if (ackcount > 0)
        {
            return true;
        }
        if (probe != 0)
        {
            return true;
        }
        if (sndBuf.size() > 0)
        {
            return true;
        }
        if (sndQueue.size() > 0)
        {
            return true;
        }
        return false;
    }

    public int getMtu()
    {
        return mtu;
    }

    public int setMtu(int mtu)
    {
        if (mtu < IKCP_OVERHEAD || mtu < 50)
        {
            return -1;
        }

        this.mtu = mtu;
        this.mss = mtu - IKCP_OVERHEAD;
        return 0;
    }

    public int getInterval()
    {
        return interval;
    }

    public int setInterval(int interval)
    {
        if (interval > 5000)
        {
            interval = 5000;
        }
        else if (interval < 10)
        {
            interval = 10;
        }
        this.interval = interval;

        return 0;
    }

    public int nodelay(boolean nodelay, int interval, int resend, boolean nc)
    {
        this.nodelay = nodelay;
        if (nodelay)
        {
            this.rxMinrto = IKCP_RTO_NDL;
        }
        else
        {
            this.rxMinrto = IKCP_RTO_MIN;
        }

        if (interval >= 0)
        {
            if (interval > 5000)
            {
                interval = 5000;
            }
            else if (interval < 10)
            {
                interval = 10;
            }
            this.interval = interval;
        }

        if (resend >= 0)
        {
            fastresend = resend;
        }

        this.nocwnd = nc;

        return 0;
    }

    public int wndsize(int sndWnd, int rcvWnd)
    {
        if (sndWnd > 0)
        {
            this.sndWnd = sndWnd;
        }
        if (rcvWnd > 0)
        {
            this.rcvWnd = rcvWnd;
        }

        return 0;
    }

    
    public int waitSnd()
    {
        return this.sndBuf.size() + this.sndQueue.size();
    }

    public int getConv()
    {
        return conv;
    }

    public void setConv(int conv)
    {
        this.conv = conv;
    }

    public Object getUser()
    {
        return user;
    }

    public void setUser(Object user)
    {
        this.user = user;
    }

    public int getState()
    {
        return state;
    }

    public void setState(int state)
    {
        this.state = state;
    }

    public boolean isNodelay()
    {
        return nodelay;
    }

    public void setNodelay(boolean nodelay)
    {
        this.nodelay = nodelay;
        if (nodelay)
        {
            this.rxMinrto = IKCP_RTO_NDL;
        }
        else
        {
            this.rxMinrto = IKCP_RTO_MIN;
        }
    }

    public int getFastresend()
    {
        return fastresend;
    }

    public void setFastresend(int fastresend)
    {
        this.fastresend = fastresend;
    }

    public boolean isNocwnd()
    {
        return nocwnd;
    }

    public void setNocwnd(boolean nocwnd)
    {
        this.nocwnd = nocwnd;
    }

    public int getRxMinrto()
    {
        return rxMinrto;
    }

    public void setRxMinrto(int rxMinrto)
    {
        this.rxMinrto = rxMinrto;
    }

    public int getRcvWnd()
    {
        return rcvWnd;
    }

    public void setRcvWnd(int rcvWnd)
    {
        this.rcvWnd = rcvWnd;
    }

    public int getSndWnd()
    {
        return sndWnd;
    }

    public void setSndWnd(int sndWnd)
    {
        this.sndWnd = sndWnd;
    }

    public boolean isStream()
    {
        return stream;
    }

    public void setStream(boolean stream)
    {
        this.stream = stream;
    }

    public int getDeadLink()
    {
        return deadLink;
    }

    public void setDeadLink(int deadLink)
    {
        this.deadLink = deadLink;
    }

    public void setByteBufAllocator(ByteBufAllocator byteBufAllocator)
    {
        this.byteBufAllocator = byteBufAllocator;
    }

    public boolean isAutoSetConv()
    {
        return autoSetConv;
    }

    public void setAutoSetConv(boolean autoSetConv)
    {
        this.autoSetConv = autoSetConv;
    }

    
    @Override
    public String toString()
    {
        return "Kcp(" + "conv=" + conv + ")";
    }
}
